The main idea is to first try to count the number of pairs of characters where each contains two different characters, denoted as \\(n\\). If \\(n > K\\), to find the minimum steps, remove the top \\(K\\) pairs by their distances, where distance of character is defined by the absolute difference of their ASCII or Unicode code point. After removing these \\(K\\) pairs, summing the rest will yield the result. If \\(n < K\\), as we are forced to change \\(K\\) characters before the operation, it means we need to increment or decrement \\(K - n\\) characters by \\(1\\). Therefore, the number of steps required to change the string will be \\(n - K\\). \\(n = K\\) can be categorised into either case, but out of considerations of performance and optimisation, \\(K - n\\) will be more efficient than selecting and removing the top K pairs. Storing the differences will always require \\(\Theta(n)\\) space. Here, \\(n <= s\\) where \\(s\\) is the length of `A` and `B`, or formally, \\(n \in O(s)\\).

For selecting top \\(K\\) pairs can be done in two different ways:

* Use the array to store the differences and sort it, or
* Use priority queue (by max heap) to store the differences directly.

As said, the amortised space complexity for each way is always \\(\Theta(n)\\). They also have same a amortised time complexity \\(O(n \log{n})\\). The only difference is removing top \\(K\\) from a sorted array and sum the rest is quite easy, which requires \\(O(n - K)\\) operations, but the heap method needs to do \\(O(n \log{n})\\) operations. Overall, both ways have same amortised time complexity \\(O(n \log{n})\\), but the first way is the preferred and implemented way.

There is another interesting implementation which may be slightly faster than previous two, which is to use a priority queue (by max heap) with fixed size, specifically, \\(s - K\\), and evict the top element when inserting if it is full. Also we need to record the number of non-zero differences, similarly, as \\(n\\). So the time complexity is \\(O(s \log{(s - K)})\\) and space complexity is \\(O(s - K)\\). Although these two complexities are asymptotically identical, it is hard to determine whether it is practically faster than the previous two since replacement of the top element in a priority queue generally requires extra operations.
